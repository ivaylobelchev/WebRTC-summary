<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>124 - WebRTC</title>
</head>
<body>
    <form class="wholePage">
    <header class="container">
        <a src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/WebRTC_Logo.svg/2560px-WebRTC_Logo.svg.png" target="_blank"><img src="images/WebRTC_Logo.png" alt="WebRTC logo" class="titleLogo"/></a>
        <h1 class="title">124 - WebRTC - принципи на работа. WebRTC с PHP</h1>
    </header>
    <main>
        <div class="topnav">
            <a href="#top">Начало</a>
            <a href="#part2">Как работи</a>
            <a href="#part3">Предимства и недостатъци</a>
            <a href="#part5">Потребност</a>
            <a href="#part6">Сигурност</a>
            <a href="#part7">Алтернативи</a>
            <a href="#part8">BigBlueButton</a>
            <a href="#part9">WebRTC в PHP</a>
            <a href="#part10">Демо</a>
            <a href="#part11">Литература</a>
        </div>

        <section class="container">
            <h2>Съдържание</h2>
            <ol>
                <a href="#part1"><li>Въведение</li></a>
                <a href="#part2"><li>Как работи WebRTC?</li></a>
                <a href="#part3"><li>Защо WebRTC е добър избор за комуникация в реално време?</li></a>
                <a href="#part4"><li>Какви са плюсовете и минусите на WebRTC?</li></a>
                <a href="#part5"><li>За какво се използва WebRTC?</li></a>
                <a href="#part6"><li>WebRTC сигурен ли е?</li></a>
                <a href="#part7"><li>Алтернативи на WebRTC</li></a>
                <a href="#part8"><li>Пример за платформа, използваща WebRTC – BigBlueButton</li></a>
                <a href="#part9"><li>WebRTC в PHP</li></a>
                <a href="#part10"><li>Демонстрация на имплементация на WebRTC в браузъра</li></a>
                <a href="#part11"><li>Списък с цитирана литература</li></a>
            </ol>
        </section>

        <section class="container">
            <h2 id="part1" class="withLinks">1. Въведение</h2>

            <h3>Какво е WebRTC?</h3>
            <p>WebRTC е HTML5 спецификация, която може да се използва за добавяне на медийни комуникации в реално време директно между браузър и устройства. Абревиатурата в името означава "Real Time Communication". <a href="#source_1">[1]</a> <a href="#source_8">[8]</a></p>
            <p>Просто казано:</p>
            <p>WebRTC дава възможност за гласова и видео комуникация да работят в уеб страници без да е необходимо никакво предварително инсталиране на плъгини в браузъра. <a href="#source_1">[1]</a></p>
            <p>Инструментът е представен през 2011 г. и оттогава популярността му постоянно нараства. Той поддържа видео, глас и данни за изпращане между пиъри, което позволява на разработчиците да изграждат гъвкави решения за гласова и видео комуникация. Технологията е достъпна за всички съвременни браузъри, както и за собствени клиенти за всички основни платформи. <a href="#source_2">[2]</a></p>
            <p>Технологиите зад WebRTC са внедрени като отворен уеб стандарт и са налични като обикновени JavaScript API във всички основни браузъри. За собствени клиенти, като приложения за Android и iOS, е налична библиотека, която предоставя същата функционалност. Проектът WebRTC е с отворен код и се поддържа от Apple, Google, Microsoft и Mozilla, наред с други. Тази страница се поддържа от екипа на Google WebRTC. <a href="#source_2">[2]</a></p>
        </section>

        <section class="container">
            <h2 id="part2" class="withLinks">2. Как работи WebRTC?</h2>

            <h3>Код и API</h3>
            <p>Важно е да разберем откъде идваме: Ако преди няколко години сте искали да създадете нещо, което позволява гласови или видео разговори, най-вероятно сте използвали C/C++ за това. Това означава дълги цикли на разработка и по-високи финансови разходи за разработка.</p>
            <p>WebRTC променя всичко това: премахва необходимостта от C/C++ и го заменя с Javascript API.</p>
            <p>Той идва с Javascript API слой отгоре, който можете да използвате в браузъра. Това прави много по-лесно разработването и интегрирането на комуникации в реално време навсякъде. Вътрешно WebRTC все още се прилага предимно с помощта на C/C++, но повечето разработчици, които използват WebRTC, няма да трябва да копаят дълбоко в тези слоеве, за да разработят своите приложения. <a href="#source_1">[1]</a></p>

            <img src="images/webrtc-browser-support.png" align="right" class="supportIMG" alt="WebRTC browser support" target="_blank">
            <h3>Наличност и поддръжка на различни платформи</h3>
            <p>WebRTC днес е наличен във всички съвременни браузъри. Поддържат го Google Chrome, Mozilla Firefox, Apple Safari и Microsoft Edge.</p>
            <p>Можете също да го „вземете“ и да го интегрирате в приложение или вградено устройство, без изобщо да имате нужда от браузър. <a href="#source_1">[1]</a> <a href="#source_9">[9]</a></p>

            <h3>Медия и достъп</h3>
            <p>Това, което прави WebRTC, е че Ви позволява да имате достъп до устройствата. Можете да получите достъп до микрофона на Вашето устройство, камерата, която имате на Вашия телефон или лаптоп – или може да бъде самият екран. Можете да заснемете дисплея на потребителя и след това този екран да бъде споделен или записан от разстояние.</p>
            <p>Каквото и да прави, е в реално време, позволявайки взаимодействия на живо.</p>
            <p>WebRTC не се ограничава до глас и видео. Позволява изпращане на всякакъв вид произволни данни. <a href="#source_1">[1]</a></p>
        </section>

        <section class="container">
            <h2 id="part3" class="withLinks">3. Защо WebRTC е добър избор за комуникация в реално време?</h2>
            <h3>Първо, WebRTC е open-source проект</h3>
            <ul>
                <li>Напълно безплатен е</li>
                <li>Постоянно еволюиращ и подобряващ се</li>
                <li>Идеален избор поради широката екосистема и компании поддръжници, които могат да помогнат с имплементацията <a href="#source_3">[3]</a></li>
            </ul>
            <h3>Наличен е на всички модерни браузъри</h3>
            <ul>
                <li>Това  позволява създаване на нови случаи на употреба и бизнес модели</li>
                <li>От вземане на урок по китара или йога – до облачни игри и социални мрежи – до медицински клоуни или групова терапия – до провеждане на мащабни професионални уебинари и предавания на живо; WebRTC е в състояние да обслужва всички тях и повече <a href="#source_3">[3]</a></li>
            </ul>
            <h3>WebRTC не е ограничен само до браузъри, защото може да се имплементира и в мобилни апликации</h3>
            <ul>
                <li>Source кодът е преносим и вече се използва в редица мобилни приложения</li>
                <li>Инструментите за разработка на софтуер (SDK) са налични и за мобилни, и за embedded устройства, така че WebRTC може да се използва навсякъде <a href="#source_3">[3]</a></li>
            </ul>
            <h3>WebRTC не е полезен само за гласови или видео разговори</h3>
            <ul>
                <li>Той е мощен и универсален инструмент</li>
                <li>Може да се използва, за да се създаде услуга за групови обаждания, да добавите запис към нея или да се използва само за доставка на данни <a href="#source_3">[3]</a></li>
            </ul>
            <h3>WebRTC приема понятието комуникационна услуга и я понижава до функция в различен тип услуга.</h3>
            <p>Така че сега можете да го вземете и просто да добавите комуникация в бизнес процеси, от които се нуждаете в рамките на Вашето приложение или бизнес. <a href="#source_3">[3]</a></p>
        </section>

        <section class="container"> 
            <h2 id="part4" class="withLinks">4. Какви са плюсовете и минусите на WebRTC?</h2>
            <h3>Предимствата на WebRTC включват следното:</h3>
            <ul>
                <li>елиминира голяма част от вътрешната ръчна интеграция, изисквана от ИТ;</li>
                <li>може да регулира качеството на комуникацията, честотната лента и потока на трафика, когато условията на мрежата се променят;</li>
                <li>поддържа се от повечето основни уеб браузъри, включително: Google Chrome за настолни компютри и устройства с Android OS, Mozilla Firefox за настолни компютри и устройства с Android, а за iOS и iPadOS само през Safari;</li>
                <li>работи на всяка операционна система, стига браузърът да поддържа WebRTC;</li>
                <li>не изисква компоненти или плъгини на трети страни; и</li>
                <li>е безплатен като софтуер с отворен код. <a href="#source_3">[3]</a></li>
            </ul>
            <h3>Недостатъците на WebRTC включват следното:</h3>

            <ul>
                <li>Всеки потребител трябва да установи връзка с P2P браузър, което прави честотната лента проблем.</li>
                <li>Разходите за поддръжка могат да бъдат високи, защото WebRTC изисква мощни сървъри.</li>
                <li>Стандартите за сигурност и поверителност все още са неясни, оставяйки на ИТ отделите да гарантират, че корпоративните стандарти за сигурност и поверителност могат да бъдат спазени.</li>
                <li>Няма окончателни стандарти за качество на услугите, което означава, че качеството на видео или аудио през Интернет може да е непостоянно. <a href="#source_3">[3]</a></li>
            </ul>
        </section>

        <section class="container">
            <h2 id="part5" class="withLinks">5. За какво се използва WebRTC?</h2>
            <p>Целта на WebRTC е да улесни P2P комуникациите в реално време през Интернет. Има няколко случая на използване на WebRTC, включително следното:</p>
            <ul>
                <li>WebRTC се използва за видео чатове и срещи на платформи за видео разговори, като Zoom, Microsoft Teams, Slack или Google Meet.</li>
                <li>Индустрии, включително здравеопазване, наблюдение и мониторинг и Интернет на нещата, използват WebRTC. Например, използването на WebRTC в телемедицината позволява на лекарите да провеждат виртуални посещения в офис с пациент през уеб браузър.</li>
                <li>В областта на домашната и бизнес сигурността и наблюдението, WebRTC се използва като свързващ агент между браузъри и охранителни камери.</li>
                <li>WebRTC се използва силно за медии в реално време.</li>
                <li>WebRTC осигурява основната връзка между инструктори и студенти за онлайн обучение. <a href="#source_3">[3]</a></li>
            </ul>
        </section>

        <section class="container">
            <h2 id="part6" class="withLinks">6. WebRTC сигурен ли е?</h2>
            <p>Всеки софтуерен компонент на WebRTC е криптиран и всеки WebRTC API изисква защитен произход чрез защитен протокол за прехвърляне на хипертекст (HTTPS) или локален хост. Въпреки това все още има отворени въпроси за сигурност, които разработчиците, използващи WebRTC, трябва да обмислят. Методите за обработка на сигнали или методите, използвани за обмен на метаданни, не са посочени за WebRTC сигнализиране. Това означава, че разработчиците трябва да решат кои протоколи за сигурност да използват и да гарантират, че избраните от тях протоколи могат да се поддържат с WebRTC. <a href="#source_3">[3]</a></p>
        </section>

        <section class="container">
            <h2 id="part7" class="withLinks">7. Алтернативи на WebRTC</h2>
            <img src="images/Skype_logopng.png" align="right" class="smallIMG2">
            <p>Една от най-известните платформи от началото на века е <b>Skype</b>. </p>
            <p>Skype е приложение, предназначено за провеждане на аудио и видео разговори, както и за обмен на текстови съобщения или файлове през Интернет. Първата версия на това приложение е пусната през 2003 г. и първоначално е адаптирана само за гласова комуникация. Като една от първите платформи, които прилагат технологията VoIP (Voice over Internet Protocol), тя придобива невероятна популярност. Според съобщението на Microsoft, направено на конференцията Build 2016, Skype все още има над 300 милиона активни потребители месечно. Като се има предвид, че Skype може да се използва на настолен компютър, мобилен телефон или през уеб браузър, няма нищо изненадващо, че това е очевидният избор в случай, че искате да се обадите на Вашия клиент или колега от другия край на земята. <a href="#source_4">[4]</a> <a href="#source_13">[13]</a></p>
            <p>WebRTC, от друга страна, не е готово за използване приложение, а технология. Тя позволява осъществяване на комуникация в реално време чрез уеб браузър. Потребителят няма нужда да инсталира допълнителен софтуер или приставка за браузър на трета страна, за да получи възможност за обмен на текстови съобщения, файлове или за да  извършва на аудио/видео разговори. Всеки разработчик ще бъде доволен от факта, че WebRTC API позволява внедряване на необходимата функционалност с минимално количество код. Тези характеристики са причината за нарастването на популярността на WebRTC. Тази технология е пусната от Google през май 2011 г. и пет години по-късно, през юни 2016 г., Google предоставя следните статистически данни: </p>
            <ul>
                <li>Два милиарда браузъра Chrome с поддръжка на WebRTC</li>
                <li>Един милиард WebRTC аудио и видео минути на седмица в Chrome</li>
                <li>1200 WebRTC-базирани компании и проекта</li>
                <li>Пет милиарда изтегляния на мобилни приложения, които включват WebRTC</li>
            </ul>
            <p>Според мнението на анализаторите глобалният пазар на WebRTC ще продължава да расте. Един от основните двигатели на пазара за комуникация в реално време в мрежата е голямото търсене на услуги за аудио/видео чат, достъпни без изтегляне на допълнителни плъгини. Нарастващият брой устройства, поддържащи WebRTC, доведе до тенденцията Bring Your Own Device (BYOD, донеси своето устройство). Това е нова тенденция на работните места, която насърчава служителите да използват собствените си мобилни устройства за нуждите на бизнес комуникацията. <a href="#source_4">[4]</a></p>
            <p>Както можете да видите, тук говорим за подобни концепции. Тези две платформи предоставят почти еднакви услуги. Начините за предоставяне на тези услуги обаче се различават. Skype е приложение за уеб комуникация, докато WebRTC е инструмент, който позволява внедряване на функционалността, необходима за уеб комуникация. Може да изглежда, че предпочитането на WebRTC пред Skype не е много мъдър избор, тъй като предполага полагане на допълнителни усилия. Вместо да използвате Skype, с който сте запознати, ще трябва да отделите известно време за проучване и да изберете решението, което отговаря по-добре на Вашите нужди сред наличните опции. Като алтернатива можете да създадете свое собствено WebRTC приложение, като използвате ресурсите на Вашата компания или да наемете компания за разработка на софтуер. <a href="#source_4">[4]</a></p>
        </section>

        <section class="container">
            <h2 id="part8" class="withLinks">8. Пример за платформа, използваща WebRTC – BigBlueButton</h2>
            <p>BigBlueButton е система за уеб конференции с open source код за онлайн обучение. Това означава:</p>
            <ul>
                <li>Open source код - има пълен достъп до source кода на BigBlueButton под лиценз с отворен код.</li>
                <li>Система за уеб конференции - BigBlueButton предоставя всички основни функции, които се очакват от комерсиална система за уеб конференции (но под лиценз с отворен код), включително споделяне в реално време на аудио, видео, презентация и екран - заедно с инструменти за сътрудничество като чат (публичен и личен), бяла дъска, споделени бележки, анкети и стаи за разбивка. BigBlueButton може да записва Вашите сесии за по-късно възпроизвеждане.</li>
                <li>Онлайн обучение – BigBlueButton разширява тези основни функции за онлайн обучение. Например, преподавателят може да отключи възможността за използване на многопотребителска бяла дъска и да работи директно с ученик при решаване на математически проблем. <a href="#source_5">[5]</a></li>
            </ul>
            <h3>Преглед на BigBlueButton</h3>
            <p>BigBlueButton е уеб приложение, базирано на HTML5. За разлика от много търговски системи за уеб конференции, които изискват да инсталирате софтуер, BigBlueButton работи изцяло в уеб браузър. За да се присъедини потребител към сесия на BigBlueButton, е нужно единствено да щракне върху връзка, която отваря валиден URL адрес за присъединяване във Вашия браузър. Сървърът BigBlueButton получава URL адреса, потвърждава го и зарежда клиента BigBlueButton. След зареждане той незабавно Ви подканва да се присъедините към аудио конференцията и да започнете да си сътрудничите. Няма плъгини за изтегляне, няма софтуер за инсталиране. BigBlueButton предоставя висококачествено аудио, видео и споделяне на екрана, като използва вградената поддръжка на браузъра за уеб библиотеки за комуникация в реално време (WebRTC). <a href="#source_5">[5]</a></p>
            <figure>
                <img src="images/BBB-overview-2.png" alt="BigBlueButton interface">
                <figcaption>Фигура 3: Интерфейс на BigBlueButton <a href="#source_10">[10]</a></figcaption>
            </figure>
            <h3>Архитектура на BigBlueButton</h3>
            <figure>
                <img src="images/bbb-overview.png" alt="BigBlueButton structure">
                <figcaption>Фигура 4: Преглед на архитектурата на BigBlueButton <a href="#source_11">[11]</a></figcaption>
            </figure>
            <p>Обясненията по-долу са само за частите, засягащи WebRTC.</p>
            <h3>HTML5 клиент</h3>
            <p>HTML5 клиентът е едностранично отзивчиво уеб приложение, което е изградено върху следните компоненти:</p>
            <ul>
                <li>React.js за изобразяване на потребителския интерфейс по ефективен начин</li>
                <li>WebRTC за изпращане/получаване на аудио и видео</li>
            </ul>
            <p>HTML5 клиентът се свързва директно със сървъра BigBlueButton през порт 443 (SSL) от зареждане на клиента BigBlueButton до създаване на връзка с уеб сокет. <a href="#source_6">[6]</a></p>
            <a href="https://docs.bigbluebutton.org/images/10/joining-voice-conf.png"><img src="images/joining-voice-conf.png" align="left" class="smallIMG" alt="joining voice conference"></a>
            <h3>FreeSWITCH</h3>
            <p>FreeSWITCH предоставя възможността за гласова конферентна връзка в BigBlueButton. Потребителите могат да се присъединят към гласовата конференция чрез слушалките. Потребителите, които се присъединяват чрез Google Chrome или Mozilla Firefox, могат да се възползват от по-високо качество на звука, като се свържат чрез WebRTC. FreeSWITCH може също да бъде интегриран с VoIP доставчици, така че потребителите, които не могат да се присъединят с помощта на слушалките, ще могат да се обаждат чрез телефона си. <a href="#source_6">[6]</a></p>
            <h3>Присъединяване към гласова конференция</h3>
            <p>Потребителят може да се присъедини към гласовата конференция (изпълняваща се във FreeSWITCH) от BigBlueButton HTML5 клиента или чрез телефона си. Когато се присъединява през клиента, потребителят може да избере да се присъедини с микрофон или само да слуша, а клиентът BigBlueButton ще направи аудио връзка със сървъра чрез WebRTC. WebRTC предоставя на потребителя висококачествен звук с по-ниска латентност <a href="#source_6">[6]</a> <a href="#source_12">[12]</a> (освен ако сървърът не се претовари отново хихихи). </p>
        </section>

        <section class="container ninth">
            <h2 id="part9" class="withLinks">9. WebRTC в PHP</h2>
            <h3>Можете ли да използвате WebRTC с PHP?</h3>
            <p>WebRTC свързва двама пиъри заедно. Пиърите са предимно браузъри, но могат да бъдат всяка комбинация пиър и клиент, поддържащи WebRTC.</p>
            <p>WebRTC изисква от двамата пиъри да обменят някаква информация, за да установят връзката - наречена сигнализиране. Тази информация може да се обменя например чрез PHP сървър. Обикновено би се използвало websockets за обмен, но и PHP може да действа като сървър на websockets. <a href="#source_14">[14]</a></p>
            <p>PHP <b>не</b> е най-ефективният сигнализиращ сървър за доставка на информация за връзка до много партньори, тъй като не е добър избор за подсигуряване на мащабируемост на събития в реално време. <a href="#source_14">[14]</a></p>
        </section>

        <section class="container">
            <h2 id="part10" class="withLinks">10. Демонстрация на имплементация на WebRTC в браузъра</h2>
            <p>Тук ще покажа примерна демонстрация на това как можем да използваме WebRTC в браузъра, като ще направим сайт, който ни прави снимки и да ни ги показва. <a href="#source_7">[7]</a></p>

            <h3>HTML интерфейс</h3>
            <p>Нашият HTML интерфейс има две основни оперативни секции: панел за поток и заснемане и панел за презентация. Всеки от тях е представен рамо до рамо в собствен &lt;div&gt;, за да се улесни стилизирането.</p>

            <p>Първият панел вляво съдържа два компонента: елемент &lt;video&gt;, който ще получава потока от WebRTC, и &lt;button&gt;, който потребителят щраква, за да заснеме видео кадър.</p>

            <figure>
                <div>
                    &lt;div class="camera"&gt;<br>
                    &emsp;&lt;video id="video"&gt;Видео стриймът не е наличен.&lt;/video&gt;<br>
                    &emsp;&lt;button id="startbutton"&gt;Направи снимка&lt;/button&gt;<br>
                    &lt;/div&gt;
                </div>
                <figcaption>Фигура 6: Код за бутона и алтернативния текст <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Това е лесно и ще видим как ще се свърже, когато влезем в кода на JavaScript.</p>

            <p>След това имаме елемент &lt;canvas&gt;, в който се съхраняват заснетите кадри, потенциално манипулирани по някакъв начин и след това конвертирани в изходен файл с изображение. Това платно се запазва скрито чрез стилизиране на платното с display:none, за да се избегне претрупването на екрана — потребителят не трябва да вижда този междинен етап.</p>

            <p>Имаме и елемент &lt;img&gt;, в който ще нарисуваме изображението — това е крайният дисплей, който се показва на потребителя.</p>

            <figure>
                <div>
                    &lt;canvas id="canvas"&gt;<br>
                    &emsp;&lt;div class="output"&gt;<br>
                    &emsp;&emsp;&lt;img id="photo" alt="Видеопотокът ще се покаже в този прозорец."&gt;<br>
                    &emsp;&lt;/div&gt;<br>
                    &lt;/canvas&gt;
                </div>
                <figcaption>Фигура 7: Код за прозореца с видеопоток <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Това е целият релевантен HTML. Останалото е само част от оформлението на страницата и малко текст, предлагащ връзка към тази страница. <a href="#source_7">[7]</a></p>

            <h3>JavaScript кодът</h3>
            <p>Сега нека да разгледаме JavaScript кода. Нека го разделим на няколко части, за да е по-лесен за обяснение.</p>

            <p><b>Инициализация</b></p>
            <p>Започваме, като обвиваме целия скрипт в анонимна функция, за да избегнем глобални променливи, след което настройваме различните променливи, които ще използваме. <a href="#source_7">[7]</a></p>

            <figure>
                <div>
                    (function() {<br>
                        &emsp;var width = 320;    // Правим снимката да е толкова широка<br>
                        &emsp;var height = 0;     // Височината ще се сметне на база на ширината<br>           

                        &emsp;var streaming = false;<br>
                    
                        &emsp;var video = null;<br>
                        &emsp;var canvas = null;<br>
                        &emsp;var photo = null;<br>
                        &emsp;var startbutton = null;<br>
                </div>
                <figcaption>Фигура 8: Функция за инициализация <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p><b>Функцията startup()</b></p>
            <p>Функцията startup() се изпълнява, когато страницата приключи зареждането, със съдействието на EventTarget.addEventListener. Работата на тази функция е да поиска достъп до уеб камерата на потребителя, да инициализира изхода &lt;img&gt; в състояние по подразбиране и да установи слушателите на събития, необходими за получаване на всеки кадър на видео от камерата и реагиране при щракване върху бутона за заснемане на изображение. <a href="#source_7">[7]</a></p>

            <p><b>Получаване на препратки към елементи</b></p>
            <p>Първо, грабваме препратки към основните елементи, до които трябва да имаме достъп.</p>

            <figure>
                <div>
                    function startup() {<br>
                        &emsp;video = document.getElementById('video');<br>
                        &emsp;canvas = document.getElementById('canvas');<br>
                        &emsp;photo = document.getElementById('photo');<br>
                        &emsp;startbutton = document.getElementById('startbutton');
                </div>
                <figcaption>Фигура 9: Функция за получаване на препратки към елементи <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p><b>Взимане на медийния поток</b></p>
            <p>Следващата задача е да получим медиен поток:</p>

            <figure>
                <div>
                    &emsp;navigator.mediaDevices.getUserMedia({ video: true, audio: false })<br>
                    &emsp;.then(function(stream) {<br>
                        &emsp;&emsp;video.srcObject = stream;<br>
                        &emsp;&emsp;video.play();<br>
                        &emsp;})<br>
                        &emsp;.catch(function(err) {<br>
                            &emsp;&emsp;console.log("An error occurred: " + err);<br>
                            &emsp;});
                </div>
                <figcaption>Фигура 10: Функция за взимане на медийния поток <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Тук извикваме MediaDevices.getUserMedia() и изискваме видео поток (без аудио). Връща обещание, към което прикачваме обратни извиквания за успех и неуспех.</p>

            <p>Успешното обратно извикване получава обект на поток като вход. Това е източникът на елемента &lt;video&gt; към нашия нов поток.</p>

            <p>След като потокът е свързан с елемента &lt;video&gt;, ние започваме да го възпроизвеждаме, като извикаме HTMLMediaElement.play().</p>

            <p>Обратното извикване за грешка се извиква, ако отварянето на потока не работи. Това ще се случи например, ако няма свързана съвместима камера или потребителят е отказал достъп. <a href="#source_7">[7]</a></p>

            <p><b>Слушане за наличието на видеопотока</b></p>
            <p>След извикване на HTMLMediaElement.play() на &lt;video&gt;, има (надявам се кратък) период от време, който изтича, преди видеопотокът от видео да започне да тече. За да избегнем блокиране, докато това не се случи, добавяме слушател на събитие към видеото за събитието canplay, което спира, когато възпроизвеждането на видеото действително започне. В този момент всички свойства на видеообекта са конфигурирани въз основа на формата на потока.</p>
            
            <figure>
                <div>
                    &emsp;video.addEventListener('canplay', function(ev){<br>
                        &emsp;&emsp;if (!streaming) {<br>
                            &emsp;&emsp;&emsp;height = video.videoHeight / (video.videoWidth/width);<br>
                
                            &emsp;&emsp;&emsp;video.setAttribute('width', width);<br>
                            &emsp;&emsp;&emsp;video.setAttribute('height', height);<br>
                            &emsp;&emsp;&emsp;canvas.setAttribute('width', width);<br>
                            &emsp;&emsp;&emsp;canvas.setAttribute('height', height);<br>
                            &emsp;&emsp;&emsp;streaming = true;<br>
                            &emsp;&emsp;}<br>
                            &emsp;}, false);
                </div>
                <figcaption>Фигура 11: Функция за слушане за наличието на видеопотока <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Това обратно извикване не прави нищо, освен ако не е извикано за първи път; това се тества чрез разглеждане на стойността на нашата променлива за стрийминг, която е фалшива при първото изпълнение на този метод.</p>

            <p>Ако това наистина е първото изпълнение, ние задаваме височината на видеоклипа въз основа на разликата в размера между действителния размер на видеото, video.videoWidth, и ширината, на която ще го изобразим, ширината.</p>

            <p>И накрая, ширината и височината както на видеото, така и на платното, се настройват да съвпадат една с друга чрез извикване на Element.setAttribute() на всяко от двете свойства на всеки елемент и задаваме ширини и височини според случая. И накрая, ние задаваме променливата за стрийминг на true, за да се предпазим от неволно стартиране на този код за настройка отново. <a href="#source_7">[7]</a></p>

            <p><b>Обработване щракванията върху бутона</b></p>
            <p>За да заснемем неподвижна снимка всеки път, когато потребителят щракне върху бутона за стартиране, трябва да добавим слушател на събитие към бутона, който да бъде извикан, когато бъде издадено събитието за щракване:</p>

            <figure>
                <div>
                    &emsp;startbutton.addEventListener('click', function(ev){<br>
                        &emsp;&emsp;takepicture();<br>
                        &emsp;&emsp;ev.preventDefault();<br>
                        &emsp;}, false);
                </div>
                <figcaption>Фигура 12: Функция за обработване на щракванията върху бутона <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Този метод е достатъчно прост: той просто извиква нашата функция takepicture(), дефинирана по-долу в раздела Заснемане на кадър от потока, след което извиква Event.preventDefault() на полученото събитие, за да предотврати кликването да бъде обработвано повече от веднъж. <a href="#source_7">[7]</a></p>

            <p><b>Завършване на метода startup()</b></p>
            <p>Има само още два реда код в метода startup():</p>

            <figure>
                <div>
                    &emsp;&emsp;clearphoto();<br>
                    &emsp;}
                </div>
                <figcaption>Фигура 13: Функция за инициализиране на метода clearphoto() <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Това е мястото, където инициализираме метода clearphoto(), който ще опишем по-долу в раздела Изчистване на полето за снимки. <a href="#source_7">[7]</a></p>

            <p><b>Изчистване на кутията за снимки</b></p>
            <p>Изчистването на полето за снимки включва създаване на изображение, след което го преобразуваме във формат, използваем от елемента &lt;img&gt;, който показва най-скоро заснетата рамка. Този код изглежда така:</>

            <figure>
                <div>
                    &emsp;function clearphoto() {<br>
                        &emsp;&emsp;var context = canvas.getContext('2d');<br>
                        &emsp;&emsp;context.fillStyle = "#AAA";<br>
                        &emsp;&emsp;context.fillRect(0, 0, canvas.width, canvas.height);<br>
                    
                        &emsp;&emsp;var data = canvas.toDataURL('image/png');<br>
                        &emsp;&emsp;photo.setAttribute('src', data);<br>
                        &emsp;}
                </div>
                <figcaption>Фигура 14: Функция за изчистване на кутията за снимки <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Започваме, като получаваме препратка към скрития елемент &lt;canvas&gt;, който използваме за изобразяване извън екрана. След това задаваме fillStyle на #AAA (доста светло сиво) и запълваме цялото платно с този цвят, като извикаме fillRect().</p>

            <p>Накрая в тази функция преобразуваме платното в PNG изображение и извикваме photo.setAttribute(), за да накараме нашата заснета неподвижна кутия да покаже изображението. <a href="#source_7">[7]</a></p>
                
            <p><b>Заснемане на кадър от потока</b></p>
            <p>Има една последна функция за дефиниране и тя е целта на цялото упражнение: функцията takepicture(), чиято задача е да улови текущо показания видео кадър, да го преобразува в PNG файл и да го изведе в полето за заснета рамка. Кодът изглежда така:</p>

            <figure>
                <div>
                    &emsp;function takepicture() {<br>
                        &emsp;&emsp;var context = canvas.getContext('2d');<br>
                        &emsp;&emsp;if (width && height) {<br>
                            &emsp;&emsp;&emsp;canvas.width = width;<br>
                            &emsp;&emsp;&emsp;canvas.height = height;<br>
                            &emsp;&emsp;&emsp;context.drawImage(video, 0, 0, width, height);<br>
                    
                            &emsp;&emsp;&emsp;var data = canvas.toDataURL('image/png');<br>
                            &emsp;&emsp;&emsp;photo.setAttribute('src', data);<br>
                            &emsp;&emsp;} else {<br>
                                &emsp;&emsp;&emsp;clearphoto();<br>
                                &emsp;&emsp;}<br>
                                &emsp;}
                </div>
                <figcaption>Фигура 15: Функция за заснемане на кадър от потока <a href="#source_7">[7]</a></figcaption>
            </figure>

            <p>Както всеки път, когато трябва да работим със съдържанието на платно, започваме с получаване на контекста на 2D drawing context платно.</p>

            <p>След това, ако и ширината, и височината са различни от нула (което означава, че има поне потенциално валидни данни за изображението), ние задаваме ширината и височината на платното да съвпадат с тази на заснетия кадър, след което извикваме drawImage(), за да нарисуваме текущия кадър на видеото в контекста, запълвайки цялото платно с изображението на рамката.</p>

            <p>След като платното съдържа заснетото изображение, ние го преобразуваме във формат PNG, като извикаме HTMLCanvasElement.toDataURL() върху него; накрая, ние извикваме photo.setAttribute(), за да накараме нашата заснета неподвижна кутия да покаже изображението.</p>

            <p>Ако няма налично валидно изображение (тоест и ширината, и височината са 0), изчистваме съдържанието на заснетата рамка, като извикаме clearphoto(). <a href="#source_7">[7]</a></p>

            <h2>Демо:</h2>
            <p><b>Ако не работи правилно, моля обновете страницата и дайте достъп до камерата Ви.</b> Всичко се обработва локално.</p>

            <form>
                <figure>
                    <div class="contentarea">
                        <h1>
                            WebRTC: Демо, заснемащо статична снимка
                        </h1>
                        <p>
                            Този пример демонстрира как се настройва медиен стрийм, който да използва Вашата вградена уеб камера, да взема снимка от стрийма и да я записва като PNG.
                        </p>
                        <div class="camera">
                            <video id="video">Видео стриймът не е наличен</video>
                            <button id="startbutton">Направи снимка, получи изненада!</button>
                        </div>
                        <canvas id="canvas">
                        </canvas>
                        <div class="output">
                            <img id="photo" alt="Вашият образ ще се покаже в този прозорец, ако всичко функционира правилно. WebRTC изисква https, така че ако виждате тази страница без https, това демо няма как да работи.">
                        </div>
                    </div>
                    <figcaption>Фигура 16: Демо, заснемащо статична снимка <a href="#source_7">[7]</a></figcaption>
                    <figcaption>Работещо демо на: <a href="https://ivaylobelchev.github.io/WebRTC-summary/">https://ivaylobelchev.github.io/WebRTC-summary/</a></figcaption>
                </figure>
            
                <script>
                    (function () {
            
                        var width = 320;
                        var height = 0;
            
                        var streaming = false;
            
                        var video = null;
                        var canvas = null;
                        var photo = null;
                        var startbutton = null;
            
                        function showViewLiveResultButton() {
                            if (window.self !== window.top) {
                                document.querySelector(".contentarea").remove();
                                const button = document.createElement("button");
                                button.textContent = "View live result of the example code above";
                                document.body.append(button);
                                button.addEventListener('click', () => window.open(location.href));
                                return true;
                            }
                            return false;
                        }
            
                        function startup() {
                            if (showViewLiveResultButton()) { return; }
                            video = document.getElementById('video');
                            canvas = document.getElementById('canvas');
                            photo = document.getElementById('photo');
                            startbutton = document.getElementById('startbutton');
            
                            navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                                .then(function (stream) {
                                    video.srcObject = stream;
                                    video.play();
                                })
                                .catch(function (err) {
                                    console.log("An error occurred: " + err);
                                });
            
                            video.addEventListener('canplay', function (ev) {
                                if (!streaming) {
                                    height = video.videoHeight / (video.videoWidth / width);
            
                                    if (isNaN(height)) {
                                        height = width / (4 / 3);
                                    }
            
                                    video.setAttribute('width', width);
                                    video.setAttribute('height', height);
                                    canvas.setAttribute('width', width);
                                    canvas.setAttribute('height', height);
                                    streaming = true;
                                }
                            }, false);
            
                            startbutton.addEventListener('click', function (ev) {
                                takepicture();
                                ev.preventDefault();
                            }, false);
            
                            clearphoto();
                        }
            
                        function clearphoto() {
                            var context = canvas.getContext('2d');
                            context.fillStyle = "#AAA";
                            context.fillRect(0, 0, canvas.width, canvas.height);
            
                            var data = canvas.toDataURL('image/png');
                            photo.setAttribute('src', data);
                        }
            
                        function takepicture() {
                            var context = canvas.getContext('2d');
                            if (width && height) {
                                canvas.width = width;
                                canvas.height = height;
                                context.drawImage(video, 0, 0, width, height);
            
                                var data = canvas.toDataURL('image/png');
                                photo.setAttribute('src', data);
                                document.body.style.backgroundImage = "url(" + data +  ")";
                            } else {
                                clearphoto();
                            }
                        }
            
                        window.addEventListener('load', startup, false);
                    })();
                </script>
            
            </form>

        </section>

        <section class="container">
            <h2 id="part11" class="withLinks">11. Списък с цитирана литература</h2>
                <p id="source_1">[1] <span class="author">BlogGeek.Me</span>, <span class="paperName">What is WebRTC and What is it Good For?</span>, публикуван на 1 август 2021 г.<br><a href="https://bloggeek.me/what-is-webrtc/" target="_blank">https://bloggeek.me/what-is-webrtc/</a>, последно посетен на 12 април 2022 г.</p>
                <p id="source_2">[2] <span class="author">Google Developers</span>, <span class="paperName">WebRTC.org website</span><br><a href="https://webrtc.org/" target="_blank">https://webrtc.org/</a>, последно посетен на 12 април 2022 г.</p>
                <p id="source_3">[3] <span class="author">Mary E. Shacklett</span>, <span class="paperName">WebRTC (Web Real-Time Communications)</span><br><a href="https://www.techtarget.com/searchunifiedcommunications/definition/WebRTC-Web-Real-Time-Communications" target="_blank">https://www.techtarget.com/searchunifiedcommunications/definition/WebRTC-Web-Real-Time-Communications</a>, последно посетен на 13 април 2022 г.</p>
                <p id="source_4">[4] <span class="author">XB Software</span>, <span class="paperName">Why a Private WebRTC Video Chat App is Better for Business Than Skype</span>, публикуван на 17 юли 2018 г.<br><a href="https://xbsoftware.medium.com/why-a-private-webrtc-video-chat-app-is-better-for-business-than-skype-f1a6b2cc6e84" target="_blank">https://xbsoftware.medium.com/why-a-private-webrtc-video-chat-app-is-better-for-business-than-skype-f1a6b2cc6e84</a>, последно посетен на 13 април 2022 г.</p>
                <p id="source_5">[5] <span class="author">BigBlueButton</span>, <span class="paperName">BigBlueButton overview</span><br><a href="https://docs.bigbluebutton.org/" target="_blank">https://docs.bigbluebutton.org/</a>, последно посетен на 13 април 2022 г.</p>
                <p id="source_6">[6] <span class="author">BigBlueButton</span>, <span class="paperName">BigBlueButton architecture</span><br><a href="https://docs.bigbluebutton.org/2.2/architecture.html" target="_blank">https://docs.bigbluebutton.org/2.2/architecture.html</a>, последно посетен на 13 април 2022 г.</p>
                <p id="source_7">[7] <span class="author">MDN contributors</span>, <span class="paperName">Taking still photos with WebRTC</span>, последно променено на 14 март 2022 г.<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Taking_still_photos" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Taking_still_photos</a>, последно посетен на 14 април 2022 г.</p>
                <p id="source_8">[8] <span class="author">Wikipedia</span>, <span class="paperName">WebRTC logo</span><br><a href="https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/WebRTC_Logo.svg/2560px-WebRTC_Logo.svg.png" target="_blank">https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/WebRTC_Logo.svg/2560px-WebRTC_Logo.svg.png</a>, последно посетен на 13 април 2022 г.</p>
                <p id="source_9">[9] <span class="author">BlogGeek.Me</span>, <span class="paperName">What is WebRTC and What is it Good For?</span>, публикуван на 1 август 2021 г.<br><a href="https://bloggeek.me/wp-content/uploads/2019/12/webrtc-browser-support.png" target="_blank">https://bloggeek.me/wp-content/uploads/2019/12/webrtc-browser-support.png</a>, последно посетен на 14 април 2022 г.</p>
                <p id="source_10">[10] <span class="author">BigBlueButton</span>, <span class="paperName">BigBlueButton architecture image overview</span><br><a href="https://docs.bigbluebutton.org/images/22-overview-2.png" target="_blank">https://docs.bigbluebutton.org/images/22-overview-2.png</a>, последно посетен на 14 април 2022 г.</p>
                <p id="source_11">[11] <span class="author">BigBlueButton</span>, <span class="paperName">BigBlueButton architecture image overview</span><br><a href="https://docs.bigbluebutton.org/images/10/bbb-arch-overview.png" target="_blank">https://docs.bigbluebutton.org/images/10/bbb-arch-overview.png</a>, последно посетен на 14 април 2022 г.</p>
                <p id="source_12">[12] <span class="author">BigBlueButton</span>, <span class="paperName">BigBlueButton architecture image voice conference join</span><br><a href="https://docs.bigbluebutton.org/images/10/joining-voice-conf.png" target="_blank">https://docs.bigbluebutton.org/images/10/joining-voice-conf.png</a>, последно посетен на 14 април 2022 г.</p>
                <p id="source_13">[13] <span class="author">Wikipedia</span>, <span class="paperName">Skype logo</span><br><a href="https://bg.m.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB:Skype_logo.svg" target="_blank">https://en.wikipedia.org/wiki/Skype</a>, последно посетен на 15 април 2022 г.</p>
                <p id="source_14">[14] <span class="author">James Jordan on Quora</span>, <span class="paperName">Is there a way to use webrtc with Php?</span><br><a href="https://www.quora.com/Is-there-a-way-to-use-webrtc-with-Php" target="_blank">https://en.wikipedia.org/wiki/Skype</a>, последно посетен на 10 май 2022 г.</p>
        </section>
    </main>
    <footer>
        Ивайло Белчев, 2022
    </footer>
</form>
</body>
</html>